/*
 *  SSL client demonstration program
 *
 *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
 *  SPDX-License-Identifier: Apache-2.0
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may
 *  not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *  This file is part of mbed TLS (https://tls.mbed.org)
 */


#include "mbedtls/config.h"

#include <stdio.h>
#include <stdlib.h>
#define mbedtls_time            time
#define mbedtls_time_t          time_t
#define mbedtls_fprintf         fprintf
#define mbedtls_printf          printf
#define mbedtls_exit            exit
#define MBEDTLS_EXIT_SUCCESS    EXIT_SUCCESS
#define MBEDTLS_EXIT_FAILURE    EXIT_FAILURE

#include "mbedtls/net_sockets.h"
#include "mbedtls/debug.h"
#include "mbedtls/ssl.h"
#include "mbedtls/entropy.h"
#include "mbedtls/ctr_drbg.h"
#include "mbedtls/error.h"
#include "mbedtls/certs.h"
#include "mbedtls/oid.h"

#include <string.h>

uint8_t payload[ 1961] =  {0xd2, 0x84, 0x43, 0xa1, 0x01, 0x26, 0xa1, 0x18, 0x20, 0x59, 0x02, 0x51, 0x30, 0x82, 0x02, 0x4d,
	 0x30, 0x82, 0x01, 0xf3, 0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x07, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x00, 0x30, 0x0a, 0x06, 
	 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x04, 0x03, 0x02, 0x30, 0x73, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 
	 0x02, 0x4e, 0x4c, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x08, 0x0c, 0x02, 0x4e, 0x42, 0x31, 0x10, 0x30, 0x0e, 0x06,
	  0x03, 0x55, 0x04, 0x07, 0x0c, 0x07, 0x48, 0x65, 0x6c, 0x6d, 0x6f, 0x6e, 0x64, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04,
	   0x0a, 0x0c, 0x0a, 0x76, 0x61, 0x6e, 0x64, 0x65, 0x72, 0x73, 0x74, 0x6f, 0x6b, 0x31, 0x14, 0x30, 0x12, 0x06, 0x03, 0x55, 0x04,
	    0x0b, 0x0c, 0x0b, 0x63, 0x6f, 0x6e, 0x73, 0x75, 0x6c, 0x74, 0x61, 0x6e, 0x63, 0x79, 0x31, 0x1a, 0x30, 0x18, 0x06, 0x03, 0x55,
	     0x04, 0x03, 0x0c, 0x11, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x72, 0x61, 0x72, 0x2e, 0x73, 0x74, 0x6f, 0x6b, 0x2e, 0x6e, 0x6c, 
	  0x30, 0x1e, 0x17, 0x0d, 0x32, 0x31, 0x30, 0x39, 0x30, 0x32, 0x30, 0x37, 0x30, 0x31, 0x33, 0x30, 0x5a, 0x17, 0x0d, 0x32, 0x32, 
	  0x30, 0x39, 0x30, 0x32, 0x30, 0x37, 0x30, 0x31, 0x33, 0x30, 0x5a, 0x30, 0x5a, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04,
	  0x06, 0x13, 0x02, 0x4e, 0x4c, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x08, 0x0c, 0x02, 0x4e, 0x42, 0x31, 0x13, 0x30, 
	  0x11, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c, 0x0a, 0x76, 0x61, 0x6e, 0x64, 0x65, 0x72, 0x73, 0x74, 0x6f, 0x6b, 0x31, 0x12, 0x30,
	   0x10, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x0c, 0x09, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x31, 0x15, 0x30, 0x13,
	    0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x0c, 0x52, 0x45, 0x47, 0x49, 0x53, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x30, 0x59,
	  0x30, 0x13, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07,
	   0x03, 0x42, 0x00, 0x04, 0x58, 0x2b, 0x23, 0xd3, 0x5a, 0x34, 0xb7, 0x93, 0x59, 0x04, 0x92, 0xf0, 0xf5, 0xb3, 0x2b, 0x5d, 0x11,
	    0xc3, 0xff, 0x49, 0x5e, 0x76, 0x03, 0x3c, 0xbc, 0xcd, 0x73, 0x0c, 0x59, 0xe7, 0x13, 0x06, 0xd6, 0xe9, 0xab, 0xd0, 0x67, 0x22,
	   0x27, 0xd3, 0x1e, 0x82, 0x31, 0xfe, 0xbd, 0xda, 0x84, 0xa0, 0xcc, 0xf8, 0xaa, 0x57, 0xdc, 0xcb, 0x21, 0xfc, 0x1e, 0x42, 0xdd,
	    0xba, 0xb3, 0xe4, 0x60, 0x76, 0xa3, 0x81, 0x8a, 0x30, 0x81, 0x87, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16, 0x04,
	   0x14, 0xae, 0x16, 0x7c, 0xd8, 0x22, 0x1e, 0x7e, 0x4c, 0x1d, 0xc7, 0x9a, 0x10, 0xac, 0xa6, 0xad, 0x3b, 0x16, 0xaf, 0xd0, 0x25, 
	   0x30, 0x1f, 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0xd5, 0x03, 0x9f, 0xc7, 0x8a, 0x4d, 0xc0, 0x46,
	    0x87, 0x60, 0x19, 0x1f, 0xd7, 0x1b, 0x15, 0x34, 0xc2, 0xd8, 0x84, 0x28, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x01, 0x01,
	     0xff, 0x04, 0x02, 0x30, 0x00, 0x30, 0x27, 0x06, 0x03, 0x55, 0x1d, 0x25, 0x04, 0x20, 0x30, 0x1e, 0x06, 0x08, 0x2b, 0x06, 0x01,
	      0x05, 0x05, 0x07, 0x03, 0x1c, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x01, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05,
	       0x05, 0x07, 0x03, 0x02, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x1d, 0x0f, 0x01, 0x01, 0xff, 0x04, 0x04, 0x03, 0x02, 0x01, 0x86, 0x30,
	   0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x04, 0x03, 0x02, 0x03, 0x48, 0x00, 0x30, 0x45, 0x02, 0x20, 0x05, 0x40, 0x2b, 
	   0xdd, 0x4b, 0x7c, 0x5f, 0x38, 0x8a, 0x2b, 0x9b, 0x42, 0x8b, 0x93, 0xc0, 0x40, 0x84, 0x65, 0x62, 0x88, 0x7c, 0x98, 0x07, 0x07,
	    0x38, 0xb4, 0xf4, 0xb5, 0x3c, 0x08, 0x82, 0xe0, 0x02, 0x21, 0x00, 0xb7, 0x21, 0x18, 0x01, 0x09, 0x64, 0x17, 0x60, 0x5b, 0x29,
	     0x4d, 0x78, 0xe1, 0x47, 0x14, 0xa9, 0xb2, 0x6d, 0x05, 0xc3, 0xd6, 0xc9, 0x7e, 0x07, 0xbf, 0x9f, 0x7b, 0x67, 0xaf, 0xec, 0x06,
	      0x94, 0x59, 0x05, 0x07, 0xa1, 0x19, 0x09, 0xc5, 0xa5, 0x02, 0x74, 0x32, 0x30, 0x32, 0x32, 0x2d, 0x30, 0x34, 0x2d, 0x30, 0x31,
	   0x54, 0x31, 0x35, 0x3a, 0x31, 0x33, 0x3a, 0x33, 0x36, 0x5a, 0x07, 0x50, 0x3a, 0x1a, 0x4c, 0xe4, 0x18, 0x00, 0xf4, 0x8d, 0xe8, 
	   0xf2, 0xd8, 0x30, 0x07, 0x23, 0xdd, 0xe1, 0x0d, 0x71, 0x30, 0x30, 0x2d, 0x64, 0x30, 0x2d, 0x65, 0x35, 0x2d, 0x30, 0x32, 0x2d,
	    0x30, 0x30, 0x2d, 0x33, 0x36, 0x05, 0x40, 0x09, 0x59, 0x04, 0xc1, 0xd2, 0x84, 0x43, 0xa1, 0x01, 0x26, 0xa1, 0x18, 0x20, 0x59,
	     0x01, 0xd9, 0x30, 0x82, 0x01, 0xd5, 0x30, 0x82, 0x01, 0x5b, 0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x04, 0x31, 0x8d, 0x8a, 0x37,
	      0x30, 0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x04, 0x03, 0x02, 0x30, 0x4d, 0x31, 0x12, 0x30, 0x10, 0x06, 0x0a, 0x09,
	       0x92, 0x26, 0x89, 0x93, 0xf2, 0x2c, 0x64, 0x01, 0x19, 0x16, 0x02, 0x63, 0x61, 0x31, 0x19, 0x30, 0x17, 0x06, 0x0a, 0x09, 0x92,
	        0x26, 0x89, 0x93, 0xf2, 0x2c, 0x64, 0x01, 0x19, 0x16, 0x09, 0x73, 0x61, 0x6e, 0x64, 0x65, 0x6c, 0x6d, 0x61, 0x6e, 0x31, 0x1c,
	  0x30, 0x1a, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x13, 0x55, 0x6e, 0x73, 0x74, 0x72, 0x75, 0x6e, 0x67, 0x20, 0x48, 0x69, 0x67, 
	  0x68, 0x77, 0x61, 0x79, 0x20, 0x43, 0x41, 0x30, 0x20, 0x17, 0x0d, 0x32, 0x31, 0x30, 0x34, 0x31, 0x32, 0x30, 0x39, 0x31, 0x37,
	 0x34, 0x36, 0x5a, 0x18, 0x0f, 0x32, 0x39, 0x39, 0x39, 0x31, 0x32, 0x33, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5a, 0x30,
     0x1c, 0x31, 0x1a, 0x30, 0x18, 0x06, 0x03, 0x55, 0x04, 0x05, 0x0c, 0x11, 0x30, 0x30, 0x2d, 0x64, 0x30, 0x2d, 0x65, 0x35, 0x2d,
      0x30, 0x32, 0x2d, 0x30, 0x30, 0x2d, 0x33, 0x36, 0x30, 0x59, 0x30, 0x13, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01,
     0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07, 0x03, 0x42, 0x00, 0x04, 0xd1, 0x12, 0x2f, 0x4f, 0x5c, 0x26, 0xba,
      0x3f, 0xbe, 0x92, 0x52, 0x37, 0xf3, 0x4d, 0x99, 0x53, 0x09, 0xd7, 0x85, 0x99, 0x5a, 0xda, 0x81, 0x3f, 0xef, 0x69, 0x22, 0xe2,
       0x89, 0x36, 0x21, 0xdb, 0xa0, 0x81, 0x46, 0xa6, 0xdf, 0xf9, 0xed, 0x4a, 0x5f, 0x95, 0xde, 0x08, 0xeb, 0xd4, 0x87, 0x25, 0x5f,
        0xb9, 0x41, 0xb2, 0xff, 0x94, 0x5b, 0xba, 0xcf, 0xfe, 0x03, 0x40, 0x84, 0x89, 0x01, 0x9e, 0xa3, 0x58, 0x30, 0x56, 0x30, 0x1d,
         0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0x22, 0x78, 0x7b, 0x3f, 0x3a, 0xf8, 0x72, 0x87, 0x73, 0x94, 0xa4, 0xc6,
          0x47, 0xf4, 0xf4, 0x49, 0x59, 0x71, 0x64, 0x9b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x04, 0x02, 0x30, 0x00, 0x30, 0x2a,
           0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x01, 0x20, 0x04, 0x1e, 0x0c, 0x1c, 0x6d, 0x61, 0x73, 0x61, 0x2e, 0x68, 0x6f,
            0x6e, 0x65, 0x79, 0x64, 0x75, 0x6b, 0x65, 0x73, 0x2e, 0x73, 0x61, 0x6e, 0x64, 0x65, 0x6c, 0x6d, 0x61, 0x6e, 0x2e, 0x63, 0x61,
    0x30, 0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x04, 0x03, 0x02, 0x03, 0x68, 0x00, 0x30, 0x65, 0x02, 0x31, 0x00, 0xe2,
    0xf8, 0x58, 0x62, 0x8f, 0x20, 0x50, 0xc9, 0xb6, 0xf4, 0x27, 0xe5, 0xd4, 0x5d, 0xbb, 0xd4, 0x3d, 0xe3, 0x06, 0x04, 0x26, 0xc0,
    0x1c, 0xa8, 0x6c, 0xc1, 0x0d, 0x2c, 0x8f, 0x50, 0x01, 0xd9, 0x2f, 0x82, 0x7b, 0xd4, 0xba, 0xb5, 0x12, 0x8a, 0x76, 0x52, 0x38,
    0xa7, 0xbd, 0xaf, 0xe2, 0x9e, 0x02, 0x30, 0x01, 0x63, 0xa6, 0xf1, 0x1b, 0x51, 0x29, 0x00, 0xa7, 0x1f, 0x93, 0x39, 0xbd, 0xc3,
    0x0e, 0x81, 0xee, 0x2e, 0xcc, 0xc5, 0x25, 0x4a, 0xbd, 0xc5, 0xc5, 0x4d, 0x9d, 0x7e, 0x94, 0xa4, 0x76, 0x44, 0xa9, 0x40, 0xcf, 0x21, 0x0f, 0x10, 0x78, 0x99, 0x14, 0xfb, 0x48, 0x7a, 0x54, 0xc5, 0xf9, 0xaa, 0x59, 0x02, 0x97, 0xa1, 0x19, 0x09, 0xc5, 0xa5, 0x02, 0x74, 0x32, 0x30, 0x32, 0x32, 0x2d, 0x30, 0x34, 0x2d, 0x30, 0x31, 0x54, 0x31, 0x35, 0x3a, 0x31, 0x33, 0x3a, 0x33, 0x36, 0x5a, 0x07, 0x50, 0x3a, 0x1a, 0x4c, 0xe4, 0x18, 0x00, 0xf4, 0x8d, 0xe8, 0xf2, 0xd8, 0x30, 0x07, 0x23, 0xdd, 0xe1, 0x01, 0x02, 0x0d, 0x71, 0x30, 0x30, 0x2d, 0x64, 0x30, 0x2d, 0x65, 0x35, 0x2d, 0x30, 0x32, 0x2d, 0x30, 0x30, 0x2d, 0x33, 0x36, 0x0a, 0x59, 0x02, 0x51, 0x30, 0x82, 0x02, 0x4d, 0x30, 0x82, 0x01, 0xf3, 0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x07, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x00, 0x30, 0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x04, 0x03, 0x02, 0x30, 0x73, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x4e, 0x4c, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x08, 0x0c, 0x02, 0x4e, 0x42, 0x31, 0x10, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x04, 0x07, 0x0c, 0x07, 0x48, 0x65, 0x6c, 0x6d, 0x6f, 0x6e, 0x64, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c, 0x0a, 0x76, 0x61, 0x6e, 0x64, 0x65, 0x72, 0x73, 0x74, 0x6f, 0x6b, 0x31, 0x14, 0x30, 0x12, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x0c, 0x0b, 0x63, 0x6f, 0x6e, 0x73, 0x75, 0x6c, 0x74, 0x61, 0x6e, 0x63, 0x79, 0x31, 0x1a, 0x30, 0x18, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x11, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x72, 0x61, 0x72, 0x2e, 0x73, 0x74, 0x6f, 0x6b, 0x2e, 0x6e, 0x6c, 0x30, 0x1e, 0x17, 0x0d, 0x32, 0x31, 0x30, 0x39, 0x30, 0x32, 0x30, 0x37, 0x30, 0x31, 0x33, 0x30, 0x5a, 0x17, 0x0d, 0x32, 0x32, 0x30, 0x39, 0x30, 0x32, 0x30, 0x37, 0x30, 0x31, 0x33, 0x30, 0x5a, 0x30, 0x5a, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x4e, 0x4c, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x08, 0x0c, 0x02, 0x4e, 0x42, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c, 0x0a, 0x76, 0x61, 0x6e, 0x64, 0x65, 0x72, 0x73, 0x74, 0x6f, 0x6b, 0x31, 0x12, 0x30, 0x10, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x0c, 0x09, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x0c, 0x52, 0x45, 0x47, 0x49, 0x53, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x30, 0x59, 0x30, 0x13, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07, 0x03, 0x42, 0x00, 0x04, 0x58, 0x2b, 0x23, 0xd3, 0x5a, 0x34, 0xb7, 0x93, 0x59, 0x04, 0x92, 0xf0, 0xf5, 0xb3, 0x2b, 0x5d, 0x11, 0xc3, 0xff, 0x49, 0x5e, 0x76, 0x03, 0x3c, 0xbc, 0xcd, 0x73, 0x0c, 0x59, 0xe7, 0x13, 0x06, 0xd6, 0xe9, 0xab, 0xd0, 0x67, 0x22, 0x27, 0xd3, 0x1e, 0x82, 0x31, 0xfe, 0xbd, 0xda, 0x84, 0xa0, 0xcc, 0xf8, 0xaa, 0x57, 0xdc, 0xcb, 0x21, 0xfc, 0x1e, 0x42, 0xdd, 0xba, 0xb3, 0xe4, 0x60, 0x76, 0xa3, 0x81, 0x8a, 0x30, 0x81, 0x87, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0xae, 0x16, 0x7c, 0xd8, 0x22, 0x1e, 0x7e, 0x4c, 0x1d, 0xc7, 0x9a, 0x10, 0xac, 0xa6, 0xad, 0x3b, 0x16, 0xaf, 0xd0, 0x25, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0xd5, 0x03, 0x9f, 0xc7, 0x8a, 0x4d, 0xc0, 0x46, 0x87, 0x60, 0x19, 0x1f, 0xd7, 0x1b, 0x15, 0x34, 0xc2, 0xd8, 0x84, 0x28, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x01, 0x01, 0xff, 0x04, 0x02, 0x30, 0x00, 0x30, 0x27, 0x06, 0x03, 0x55, 0x1d, 0x25, 0x04, 0x20, 0x30, 0x1e, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x1c, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x01, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x02, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x1d, 0x0f, 0x01, 0x01, 0xff, 0x04, 0x04, 0x03, 0x02, 0x01, 0x86, 0x30, 0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x04, 0x03, 0x02, 0x03, 0x48, 0x00, 0x30, 0x45, 0x02, 0x20, 0x05, 0x40, 0x2b, 0xdd, 0x4b, 0x7c, 0x5f, 0x38, 0x8a, 0x2b, 0x9b, 0x42, 0x8b, 0x93, 0xc0, 0x40, 0x84, 0x65, 0x62, 0x88, 0x7c, 0x98, 0x07, 0x07, 0x38, 0xb4, 0xf4, 0xb5, 0x3c, 0x08, 0x82, 0xe0, 0x02, 0x21, 0x00, 0xb7, 0x21, 0x18, 0x01, 0x09, 0x64, 0x17, 0x60, 0x5b, 0x29, 0x4d, 0x78, 0xe1, 0x47, 0x14, 0xa9, 0xb2, 0x6d, 0x05, 0xc3, 0xd6, 0xc9, 0x7e, 0x07, 0xbf, 0x9f, 0x7b, 0x67, 0xaf, 0xec, 0x06, 0x94, 0x58, 0x40, 0xfc, 0x12, 0x0a, 0x59, 0x43, 0xb0, 0xd8, 0x49, 0xb5, 0xa8, 0x98, 0xdb, 0x99, 0xa4, 0x54, 0xaf, 0x88, 0xbb, 0x5f, 0xfd, 0xa1, 0x4c, 0xf6, 0x22, 0xb2, 0xcf, 0xf0, 0xc9, 0x98, 0x10, 0x4f, 0x25, 0x32, 0x46, 0x7c, 0xa2, 0x4f, 0x72, 0xc1, 0x1c, 0xa4, 0xcc, 0x12, 0x1b, 0x4f, 0x2c, 0xe3, 0xdc, 0x97, 0xa3, 0xe9, 0x8c, 0x31, 0x9f, 0x49, 0xa0, 0xaf, 0xdf, 0x49, 0xd0, 0xe7, 0xd6, 0x7c, 0x04, 0x58, 0x40, 0x1b, 0x28, 0x95, 0x14, 0xac, 0x04, 0xef, 0x08, 0x77, 0x9b, 0xe5, 0x4c, 0xa6, 0xa9, 0x4b, 0x87, 0x3a, 0xad, 0x34, 0x1e, 0x94, 0x65, 0x28, 0x55, 0x6c, 0xf4, 0xc3, 0x71, 0x07, 0x6c, 0x7d, 0x7e, 0xf4, 0x86, 0x03, 0x23, 0x93, 0x7b, 0xe3, 0x82, 0xfe, 0x61, 0x9f, 0xae, 0x65, 0xe6, 0xec, 0x52, 0x6d, 0x5f, 0x62, 0x87, 0xa5, 0x0d, 0xe8, 0xa3, 0x63, 0xe4, 0xe6, 0xdd, 0x25, 0x4f, 0x96, 0x2a};

#ifdef __GNUC__
#define UNUSED_PARAM __attribute__ ((unused))
#else /* not a GCC */
#define UNUSED_PARAM
#endif /* GCC */

/* names of files generated beforehand */


#define CA_REGIS_CRT           "./certificates/ca-regis.crt"
#define REGIS_SRV_CRT          "./certificates/regis_server-comb.crt"
#define REGIS_SRV_KEY          "./certificates/regis_server.key"
#define PLEDGE_CRT             "./certificates/sandelman_pledge.crt"
#define REGIS_SERVER_DER       "./certificates/regis_server.der"

#define POST_REQUEST_RV "POST /.well-known/brski/requestvoucher HTTP/1.0\r\n"
#define COSE_CBOR "Content-Type: application/voucher-cose+cbor\r\n"
#define JSON_CMS "Content-Type: application/voucher-cms+json\r\n"
#define POST_REQUEST_RA "POST /.well-known/brski/requestauditlog HTTP/1.0\r\n"
#define ACCEPT "Accept: application/voucher-cose+cbor\r\n"
#define HOST "Host: "
#define CONTENT_LENGTH "Content-Length: "
#define STARTPL "\r\n\r\n"

#define SERVER_PORT "443"
#define SERVER_NAME "masa.honeydukes.sandelman.ca"
#define GET_REQUEST "GET /status.json HTTP/1.1"
#define TEXT_PLAIN  "Content-Type: application/json"

#define CN_NAME "junk.sandelman.ca"

#define DEBUG_LEVEL 1


#define CHECK( x )                                                      \
    do {                                                                \
        int CHECK__ret_ = ( x );                                        \
        if( CHECK__ret_ < 0 )                                          \
        {                                                               \
            char CHECK__error_[100];                                    \
            mbedtls_strerror( CHECK__ret_,                              \
                              CHECK__error_, sizeof( CHECK__error_ ) ); \
            mbedtls_printf( "%s -> %s\n", #x, CHECK__error_ );        \
            ok = 1;                                                     \
            goto exit;                                                  \
        }                                                               \
    } while( 0 )


typedef struct coap_string_t{
   uint8_t *s;
   size_t  length;
} coap_string_t;

typedef struct pki_sni_entry {
  char *sni;
  mbedtls_x509_crt *cacert;
  mbedtls_x509_crt *public_cert;
  mbedtls_pk_context *private_key;
} pki_sni_entry;


/* write_file_mem
 * write from memory contained in contents to file
 * returns ok = 0; nok = 1;
 */
uint8_t 
write_file_mem(const char* file, coap_string_t *contents) {
  FILE *f = fopen(file, "w");
  
  if (f == NULL){
      printf( "file %s cannot be opened\n", file);
	  return 1;
  }
  size_t size = fwrite( contents->s, contents->length, 1, f);
  fclose( f);
  if (size == 1)return 0;
  return 1;
}

/* return_oid
 * returns value of specified OID of x509 v3 ca certificate 
 * returns Ok =0 , Nok 1
 * IN:  asn is pointer to certificate asn1 string
 * IN:  oid_name contains oid identifier
 * OUT: oid_value contains returned oid value
 */
int8_t
return_oid( mbedtls_x509_buf *asn, coap_string_t *oid_name, coap_string_t *oid_value){
	if ((asn == NULL) || (oid_name == NULL) || (oid_value == NULL))return 1;
	if (oid_name->s == NULL) return 1;
    char err_buf[256];       
    int     ret = 0;
    int ok = 0;
    int tag = asn->tag;                /**< ASN1 type, e.g. MBEDTLS_ASN1_UTF8_STRING. */
    size_t len = asn->len;             /**< ASN1 length, in octets. */
    unsigned char *p = asn->p;         /**< ASN1 data, e.g. in ASCII. */
    const unsigned char *end = p + len;  
/* sequence of sequences expected */
   CHECK( mbedtls_asn1_get_tag(&p, end, &len ,
        MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE));


    while (p < end){
		int found = 0;
		size_t qlen = 0;
		/* get a sequence from the sequence of sequences */
	    ret = mbedtls_asn1_get_tag(&p, end, &qlen ,
        MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE);
		if ( ret == 0){
			unsigned char *q = p;
	        unsigned char *qend = q + qlen;
	        while (q < qend){
		       size_t plen;
		       q++;
	           CHECK( mbedtls_asn1_get_len(&q, end, &plen));
	           tag = *(q-2);
	           if (tag == MBEDTLS_ASN1_OID){
				  if (*(q-1) == oid_name->length){
					found = 1;
	                for ( uint qq = 0; qq < oid_name->length; qq++){
	                  if (oid_name->s[qq] != q[qq])found = 0;
				    }
				 }
			   } 
			   if ((found == 1) && (tag == MBEDTLS_ASN1_OCTET_STRING)){
				   oid_value->length = plen;
		           oid_value->s = malloc(plen);
				   memcpy(oid_value->s, q, plen);
				   return 0;
			   }
	           q = q + plen;
	        }
	    }  /* if */
	    p = p + qlen;   
	} 
exit: 
	return 1;  
}  

/* return_MASAurl
 * returns MASAurl in x509 v3 ca certificate 
 * returns Ok =0 , Nok 1
 * asn is pointer to subject asn1 string
 *  contains returned key identifier
 */
static int8_t
return_MASAurl( mbedtls_x509_buf *asn, coap_string_t *MASA_url){
	uint8_t   url[8] = {0x2b, 0x06, 0x01, 0x05, 0x05,0x07,0x01,0x20};
	coap_string_t oid_name = {.length = sizeof(url), .s = url};
	coap_string_t temp = {.length = 0, .s = NULL};
	int8_t ok = return_oid( asn, &oid_name, &temp);
	/* in this case return string is preceded by 2 character */
	/* add NULL string at end */
	if (temp.s != NULL){
	  MASA_url->length = temp.length -1;
	  MASA_url->s = malloc(temp.length - 1);
	  memcpy(MASA_url->s, temp.s+2, temp.length -2);
	  MASA_url->s[temp.length - 2] = 0;
	  free(temp.s);
    }
    return ok;
}

static void
create_port(coap_string_t *host_name, coap_string_t *port_name){
	uint8_t fnd = 0;
	for (uint8_t qq = 0; qq < host_name->length; qq++)if (host_name->s[qq] == ':')fnd = qq;
	if (fnd == 0){  /* default port */
		port_name->s = malloc(sizeof(SERVER_PORT)+1);
		port_name->length = sizeof(SERVER_PORT);
		memcpy(port_name->s, SERVER_PORT, sizeof(SERVER_PORT));
		port_name->s[sizeof(SERVER_PORT)] = 0;
	} else {/* use specified port */
	    port_name->s = malloc(host_name->length - fnd);
		port_name->length = host_name->length - fnd;
		memcpy(port_name->s, host_name->s + fnd + 1, host_name->length - fnd - 1);
	    port_name->s[host_name->length - fnd] = 0;
	    host_name->length = fnd;
	    host_name->s[fnd] = 0;
	}
}

static void my_debug( void *ctx, int level,
                      const char *file, int line,
                      const char *str )
{
    ((void) level);

    mbedtls_fprintf( (FILE *) ctx, "%s:%04d: %s", file, line, str );
    fflush(  (FILE *) ctx  );
}

char*
get_san_or_cn_from_cert(mbedtls_x509_crt *crt)
{
  if (crt) {
    mbedtls_asn1_named_data * cn_data = NULL;

    if (crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME) {
      mbedtls_asn1_sequence *seq = &crt->subject_alt_names;
      while (seq && seq->buf.p == NULL) {
        seq = seq->next;
      }
      if (seq) {
        // Return the Subject Alt Name 
        return strndup((const char *)seq->buf.p,
                             seq->buf.len);
      }
    }
    cn_data = mbedtls_asn1_find_named_data(&crt->subject,
                                           MBEDTLS_OID_AT_CN,
                                           MBEDTLS_OID_SIZE(MBEDTLS_OID_AT_CN));
    if (cn_data) {
//       Return the Common Name 
      return (char *)strndup((const char *)cn_data->val.p,
                             cn_data->val.len);
    }
  }
  return NULL;
}

int 
cert_verify_callback_mbedtls(void *data UNUSED_PARAM, 
                             mbedtls_x509_crt *crt,
                             int depth, 
                             uint32_t *flags UNUSED_PARAM)
{
  char *cn = get_san_or_cn_from_cert(crt);
  printf( "CN '%s' presented by client (%s)\n",
           cn, depth ? "CA" : "Certificate");

	printf(" certificate to be written to %s \n", REGIS_SERVER_DER);
    char file[] = REGIS_SERVER_DER;
    coap_string_t contents = {.length = crt->raw.len, .s = NULL};
    contents.s = malloc(crt->raw.len);
    memcpy(contents.s, crt->raw.p, crt->raw.len);
    uint8_t ok = write_file_mem(file, &contents); 
    free(contents.s); 
    if (ok != 0)printf( "certificate is not written to %s \n", REGIS_SERVER_DER);    
    return 0;
}

int sni_callback( void *p_info, mbedtls_ssl_context *ssl,
              const unsigned char *name, size_t name_len )
{
	 printf("\n\nsni_callback with name:  ");
	 for (uint8_t qq = 0; qq < (uint8_t)name_len; qq++)printf("%c",name[qq]);
	 printf("\n\n");
     pki_sni_entry *cur = (pki_sni_entry *)p_info;
     mbedtls_ssl_set_hs_ca_chain( ssl, cur->public_cert, NULL );     
     return( mbedtls_ssl_set_hs_own_cert( ssl, cur->public_cert, cur->private_key ) );

    /* certificate not found: return an error code */
    return( -1 );
}

int main( void )
{
    int ret = 1, len;
    int ok = 0;
    int exit_code = MBEDTLS_EXIT_FAILURE;
    mbedtls_net_context server_fd;
    uint32_t flags;
    unsigned char buf[3000];
    const char *pers   = "example2_client";
    /*  registrar certificates generated by peter van der Stok */
    char ca_file_name[]     = CA_REGIS_CRT;
    char client_file_name[] = REGIS_SRV_CRT;
    char  key_file_name[]   = REGIS_SRV_KEY; 

    char  passwd[] = "watnietweet";
    pki_sni_entry entry;

    mbedtls_entropy_context entropy;
    mbedtls_ctr_drbg_context ctr_drbg;
    mbedtls_ssl_context ssl;
    mbedtls_ssl_config conf;
    mbedtls_x509_crt cacert;
    mbedtls_x509_crt cltcert;
    mbedtls_pk_context pkey;

#if defined(MBEDTLS_DEBUG_C)
    mbedtls_debug_set_threshold( DEBUG_LEVEL );
#endif

    /*
     * 0. Initialize the RNG and the session data
     */
    mbedtls_net_init( &server_fd );
    mbedtls_ssl_init( &ssl );
    mbedtls_ssl_config_init( &conf );
    mbedtls_x509_crt_init( &cacert );
    mbedtls_x509_crt_init( &cltcert );
    mbedtls_pk_init( &pkey );    
    mbedtls_ctr_drbg_init( &ctr_drbg );

    mbedtls_printf( "\n  . Seeding the random number generator..." );
    fflush( stdout );

    mbedtls_entropy_init( &entropy );
    CHECK(mbedtls_ctr_drbg_seed( &ctr_drbg, mbedtls_entropy_func, &entropy,
                               (const unsigned char *) pers,
                               strlen( pers ) ) );
    mbedtls_printf( " ok\n" );
    
    /*
     * -1 read host/port from pledge certificate
     */
     mbedtls_x509_crt pledge_crt;
     mbedtls_x509_crt_init( &pledge_crt );
     char pledge_name[] = PLEDGE_CRT;
     mbedtls_printf( "  . Loading the pledge certificate ... name %s ", pledge_name);
     CHECK(mbedtls_x509_crt_parse_file( &pledge_crt, pledge_name));
     mbedtls_printf( " ok\n" ); 
     coap_string_t MASA_url = { .s = NULL, .length = 0};
     coap_string_t port_url = { .s = NULL, .length = 0};
     ok = return_MASAurl( &pledge_crt.v3_ext, &MASA_url);
     if (ok != 0){ 
	    mbedtls_printf( "no MASAurlextension found \n");
	    goto exit;
     } 
     create_port(&MASA_url, &port_url);
     mbedtls_printf( "host is %s, port is %s \n", (char *)MASA_url.s, (char *)port_url.s);
    /*
     * 0. Initialize certificates
     */

    mbedtls_printf( "  . Loading the CA root certificate ... name %s ", client_file_name);
    CHECK(mbedtls_x509_crt_parse_file( &cacert, client_file_name ));
    mbedtls_printf( " ok\n" );  
    mbedtls_printf( "  . Loading the server certificate ... name %s ", client_file_name);
    CHECK(mbedtls_x509_crt_parse_file( &cltcert, client_file_name ));
    mbedtls_printf(" ok \n");
    mbedtls_printf( "  . Loading the CA root certificate ... name %s ", ca_file_name);
    CHECK(mbedtls_x509_crt_parse_file( &cacert, ca_file_name ));
    mbedtls_printf(" ok \n");
    mbedtls_printf( "  . Loading the server key file ... name %s ...", key_file_name);
    CHECK(mbedtls_pk_parse_keyfile( &pkey, key_file_name, passwd ));
    mbedtls_printf( " ok \n" );

    /*
     * 1. Start the connection
     */
    mbedtls_printf( "  . Connecting to tcp/%s:%s...", (char *)MASA_url.s, (char *)port_url.s );

    CHECK(mbedtls_net_connect( &server_fd, SERVER_NAME,
                                         SERVER_PORT, MBEDTLS_NET_PROTO_TCP ) );
    mbedtls_printf( " ok\n" );

    /*
     * 2. Setup stuff
     */
    mbedtls_printf( "  . Setting up the SSL/TLS structure..." );
    CHECK(mbedtls_ssl_config_defaults( &conf,
                    MBEDTLS_SSL_IS_CLIENT,
                    MBEDTLS_SSL_TRANSPORT_STREAM,
                    MBEDTLS_SSL_PRESET_DEFAULT ) );
    mbedtls_printf( " ok\n" );

    /* OPTIONAL is not optimal for security,
     * but makes interop easier in this simplified example */
    mbedtls_ssl_conf_authmode( &conf, MBEDTLS_SSL_VERIFY_OPTIONAL );     
//    mbedtls_ssl_conf_authmode( &conf, MBEDTLS_SSL_VERIFY_NONE );
    mbedtls_ssl_conf_ca_chain( &conf, &cacert, NULL );    
    mbedtls_ssl_conf_verify(&conf, cert_verify_callback_mbedtls, &entry);
 
    CHECK(mbedtls_ssl_conf_own_cert( &conf, &cltcert, &pkey ) );
    mbedtls_ssl_conf_rng( &conf, mbedtls_ctr_drbg_random, &ctr_drbg );
    mbedtls_ssl_conf_dbg( &conf, my_debug, stdout );

    entry.cacert = &cacert;
    entry.public_cert = &cltcert;
    entry.private_key = &pkey;
 
    mbedtls_ssl_conf_sni( &conf, sni_callback, &entry );
    CHECK(mbedtls_ssl_setup( &ssl, &conf ) );
    CHECK( mbedtls_ssl_set_hostname( &ssl, (char *)MASA_url.s ) );
    mbedtls_ssl_set_bio( &ssl, &server_fd, mbedtls_net_send, mbedtls_net_recv, NULL );
    /*
     * 4. Handshake
     */
    mbedtls_printf( "  . Performing the SSL/TLS handshake..." );

    while( ( ret = mbedtls_ssl_handshake( &ssl ) ) != 0 )
    {
        if( ret != MBEDTLS_ERR_SSL_WANT_READ && ret != MBEDTLS_ERR_SSL_WANT_WRITE )
        {
            char CHECK__error_[100];
            mbedtls_strerror( ret, 
                              CHECK__error_, sizeof( CHECK__error_ ) );
            mbedtls_printf( "mbedtls_ssl_handshake -> %s\n", CHECK__error_ );
            goto exit;
        }
    }
    mbedtls_printf( " ok\n" );

    /*
     * 5. Verify the server certificate
     */
    mbedtls_printf( "  . Verifying peer X.509 certificate..." );
    if( ( flags = mbedtls_ssl_get_verify_result( &ssl ) ) != 0 )
    {
        char vrfy_buf[512];
        mbedtls_printf( " failed\n" );
        mbedtls_x509_crt_verify_info( vrfy_buf, sizeof( vrfy_buf ), "  ! ", flags );
        mbedtls_printf( "%s\n", vrfy_buf );
    }
    else
        mbedtls_printf( " ok\n" );

    /*
     * 3. Write the GET/POSTrequest
     */
    mbedtls_printf( "  > Write to server: " );
    len = sprintf( (char *) buf, "%s\r\nHost: %s\r\n", POST_REQUEST_RV, SERVER_NAME );
    memcpy( (char *) buf + len, COSE_CBOR, sizeof(COSE_CBOR)-1);
    len += sizeof(COSE_CBOR)-1; 
    memcpy((char *) buf + len, CONTENT_LENGTH, sizeof(CONTENT_LENGTH)-1);
    len += sizeof(CONTENT_LENGTH)-1;  
    len += sprintf((char *) buf + len, "%d", (int)sizeof(payload)); 
    memcpy((char *)buf + len, STARTPL, sizeof(STARTPL)-1);
    len += sizeof(STARTPL)-1;
    int stpl = len;  
    memcpy((char *) buf + len, payload, sizeof(payload)); 
    len += sizeof(payload);
    if (len > sizeof(buf)){
		mbedtls_printf("len %d is larger than %d \n",(int)len, (int)sizeof(buf));
		goto exit;
	}
    printf("buf contains %d bytes with header size %d, and payload size %d \n", len, stpl, len - stpl); 
    for (int qq = 0; qq < stpl; qq++)printf("%c",buf[qq]);
    printf("\n\npayload in hex \n");  
    for (int qq = stpl; qq < len; qq++)printf(" %02x",buf[qq]);
    printf("\n\n");        
    while( ( ret = mbedtls_ssl_write( &ssl, buf, len ) ) <= 0 )
    {
        if( ret != MBEDTLS_ERR_SSL_WANT_READ && ret != MBEDTLS_ERR_SSL_WANT_WRITE )
        {
            mbedtls_printf( " failed\n  ! mbedtls_ssl_write returned %d\n\n", ret );
            goto exit;
        }
    }
    len = ret;
    mbedtls_printf( " %d bytes written\n\n", len );

    /*
     * 7. Read the HTTP response
     */
    mbedtls_printf( "  < Read from server:\n" );

    do
    {
        len = sizeof( buf ) - 1;
        memset( buf, 0, sizeof( buf ) );
        ret = mbedtls_ssl_read( &ssl, buf, len );

        if( ret == MBEDTLS_ERR_SSL_WANT_READ || ret == MBEDTLS_ERR_SSL_WANT_WRITE )
            continue;

        if( ret == MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY )
            break;

        if( ret < 0 )
        {
            mbedtls_printf( "failed\n  ! mbedtls_ssl_read returned %d\n\n", ret );
            break;
        }

        if( ret == 0 )
        {
            mbedtls_printf( "\n\nEOF\n\n" );
            break;
        }

        len = ret;
        mbedtls_printf( " %d bytes read\n\n%s", len, (char *) buf );
    }
    while( 1 );

    mbedtls_ssl_close_notify( &ssl );

    exit_code = MBEDTLS_EXIT_SUCCESS;

exit:
        mbedtls_printf("Last error was: %d \n\n", ok );

    mbedtls_net_free( &server_fd );

    mbedtls_x509_crt_free( &cacert );
    mbedtls_x509_crt_free( &cltcert );    
    mbedtls_pk_free( &pkey);
    mbedtls_ssl_free( &ssl );
    mbedtls_ssl_config_free( &conf );
    mbedtls_ctr_drbg_free( &ctr_drbg );
    mbedtls_entropy_free( &entropy );

#if defined(_WIN32)
    mbedtls_printf( "  + Press Enter to exit this program.\n" );
    fflush( stdout ); getchar();
#endif

    mbedtls_exit( exit_code );
}
